---
layout: post
title:  "API"
date:   2023-02-27 09:12:10 +0800
categories: api
---

<br/>

---

<br/>

### 1. [What is an API?](https://twitter.com/alexxubyte/status/1560642328259219457)

![What is an API](https://pbs.twimg.com/media/FaiDYWBUEAARdQc?format=jpg&name=medium)

<br/>

---

<br/>

### 2. [How to design a secure web API access for you website?](https://twitter.com/alexxubyte/status/1514256018187816965)

> When we open web API access to users, we need to make sure each API call is authenticated. 
> This means the user must be who they claim to be.
>
> In this post, we explore two common ways:
> 1. Token based authentication
> 2. HMAC (Hash-based Message Authentication Code) authentication
> 
> The diagram below illustrates how they work.

![How to design a secure web API](https://pbs.twimg.com/media/FQO3bJ8VUAUGXCz?format=jpg&name=large)

ğ“ğ¨ğ¤ğğ§ ğ›ğšğ¬ğğ
- Step 1 - the user enters their password into the client, and the client sends the password to the Authentication Server.
- Step 2 - the Authentication Server authenticates the credentials and generates a token with an expiry time.
- Steps 3 and 4 - now the client can send requests to access server resources with the token in the HTTP header. This access is valid until the token expires.

ğ‡ğŒğ€ğ‚ ğ›ğšğ¬ğğ
> This mechanism generates a Message Authentication Code (signature) by using a hash function (SHA256 or MD5).

- Steps 1 and 2 - the server generates two keys, one is Public APP ID (public key) and the other one is API Key (private key).
- Step 3 - we now generate a HMAC signature on the client side (hmac A). This signature is generated with a set of attributes listed in the diagram.
- Step 4 - the client sends requests to access server resources with hmac A in the HTTP header.
- Step 5 - the server receives the request which contains the request data and the authentication header. It extracts the necessary attributes from the request and uses the API key thatâ€™s stored on the server side to generate a signature (hmac B.)
- Steps 6 and 7 - the server compares hmac A (generated on the client side) and hmac B (generated on the server side). If they are matched, the requested resource will be returned to the client.

<br/>

---

<br/>

### 3. [What does API gateway do?](https://twitter.com/alexxubyte/status/1567177071725793283)

> The diagram below shows the detail.

![API gateway](https://pbs.twimg.com/media/Fb-7PINaMAMwGse?format=jpg&name=large)

- Step 1 - The client sends an HTTP request to the API gateway.
- Step 2 - The API gateway parses and validates the attributes in the HTTP request.
- Step 3 - The API gateway performs whitelist or blacklist checks.
- Step 4 - The API gateway talks to an identity provider for authentication and authorization.
- Step 5 - The rate limiting rules are applied to the request. If it is over the limit, the request is rejected.
- Steps 6 and 7 - Now that the request has passed basic checks, the API gateway finds the relevant service to route to by path matching.
- Step 8 - The API gateway transforms the request into the appropriate protocol and sends it to backend microservices.
- Steps 9-12: The API gateway can handle errors properly, and deals with faults if the error takes a longer time to recover (circuit break). It can also leverage ELK (Elastic-Logstash-Kibana) stack for logging and monitoring. We sometimes cache data in the API gateway.

<br/>

---

<br/>

### 4. [How does ğ ğ‘ğğ‚ work?](https://twitter.com/alexxubyte/status/1589661228502171649)

> RPC (Remote Procedure Call) is called â€œğ«ğğ¦ğ¨ğ­ğâ€ because it enables communications between remote services when services are deployed to different servers. 
> From the userâ€™s point of view, it acts like a local function call.
>
> The diagram below illustrates the overall data flow for ğ ğ‘ğğ‚.

![How does ğ ğ‘ğğ‚ work](https://pbs.twimg.com/media/Fg-cdXRVEAArIQf?format=jpg&name=large)

- Step 1: A REST call is made from the client. The request body is usually in JSON format.
- Steps 2 - 4: The order service (gRPC client) receives the REST call, transforms it, and makes an RPC call to the payment service. gPRC encodes the ğœğ¥ğ¢ğğ§ğ­ ğ¬ğ­ğ®ğ› into a binary format and sends it to the low-level transport layer.
- Step 5: gRPC sends the packets over the network via HTTP2. Because of binary encoding and network optimizations, gRPC is said to be 5X faster than JSON.
- Steps 6 - 8: The payment service (gRPC server) receives the packets from the network, decodes them, and invokes the server application.
- Steps 9 - 11: The result is returned from the server application, and gets encoded and sent to the transport layer.
- Steps 12 - 14: The order service receives the packets, decodes them, and sends the result to the client application.

<br/>

---

<br/>

### 5. [What is GraphQL?](https://twitter.com/alexxubyte/status/1567539463072673792)

> The diagram below shows the quick comparison between REST and GraphQL.

![What is GraphQL](https://pbs.twimg.com/media/FcEE056aIAUU7YS?format=jpg&name=large)

- GraphQL is a query language for APIs developed by Meta. It provides a complete description of the data in the API and gives clients the power to ask for exactly what they need.
- GraphQL servers sit in between the client and the backend services.
- GraphQL can aggregate multiple REST requests into one query. GraphQL server organizes the resources in a graph.
- GraphQL supports queries, mutations (applying data modifications to resources), and subscriptions (receiving notifications on schema modifications).

<br/>

---

<br/>

### 6. [SOAP vs REST vs GraphQL vs RPC](https://twitter.com/alexxubyte/status/1506298328878780419)

> The diagram below show the differences among API architechture types.

![api architechture](/assets/images/api.jpg)

> Over time, different API architectural styles are released. Each of them has its own patterns of standardizing data exchange.
>
> The diagram below illustrates the API timeline and API styles comparison.

![SOAP vs REST vs GraphQL vs RPC](https://pbs.twimg.com/media/FOdyTR1XwAM-JSH?format=jpg&name=medium)
